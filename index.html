<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ˜‹ è±†è±†ä¹å›­ Â· è¶…ä¸æ»‘åƒè±†è±†</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: linear-gradient(145deg, #1a2f35 0%, #0b4048 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Quicksand', 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 12px;
        }

        .game-container {
            background: #295b63;
            padding: 25px 30px 30px 30px;
            border-radius: 70px 70px 50px 50px;
            box-shadow: 0 18px 0 #0d3a3f, 0 30px 35px rgba(0, 0, 0, 0.6);
            border: 5px solid #ffd78c;
            transition: box-shadow 0.2s;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 35px;
            background: #123138;
            box-shadow: inset 0 0 0 5px #bf9f6f, 0 14px 0 #052127;
            width: 520px;
            height: 520px;
            cursor: none;
            transition: filter 0.2s;
        }

        .stats-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 20px 8px 8px 8px;
            padding: 0 5px;
        }

        .score-panel {
            background: #281f19;
            padding: 6px 30px 6px 25px;
            border-radius: 50px;
            box-shadow: inset 0 4px 0 #624d37, 0 7px 0 #0e282c;
            color: #ffecbb;
            font-weight: 700;
            font-size: 1.5rem;
            display: flex;
            gap: 35px;
            letter-spacing: 0.5px;
        }

        .score-panel div {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .score-panel span {
            background: #4e3827;
            padding: 5px 22px;
            border-radius: 40px;
            font-size: 2rem;
            line-height: 1;
            color: #fedb9e;
            box-shadow: inset 0 -3px 0 #a07246;
            min-width: 70px;
            text-align: center;
        }

        .button-group {
            display: flex;
            gap: 18px;
        }

        .action-btn {
            background: #fbc96c;
            border: none;
            font-size: 1.9rem;
            font-weight: bold;
            color: #272019;
            padding: 12px 32px;
            border-radius: 60px;
            box-shadow: 0 9px 0 #b07626, 0 5px 18px #ffcf8a;
            transition: all 0.08s ease-out;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            line-height: 1;
        }

        .action-btn:active {
            transform: translateY(7px);
            box-shadow: 0 3px 0 #b07626, 0 8px 20px #ffbb66;
        }

        .hint-area {
            color: #fbefd3;
            text-align: center;
            margin-top: 16px;
            font-size: 1.25rem;
            background: #2b707d;
            padding: 10px 30px;
            border-radius: 60px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
            border: 3px solid #ffcf81;
            font-weight: 600;
            backdrop-filter: blur(2px);
            box-shadow: 0 5px 0 #154249;
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .hint-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .emoji-badge {
            background: #f7b731;
            padding: 4px 12px;
            border-radius: 40px;
            font-size: 1.7rem;
        }

        .pulse {
            animation: soft-pulse 1.8s infinite;
        }

        @keyframes soft-pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.02); }
            100% { opacity: 1; transform: scale(1); }
        }
    </style>
    <!-- ä½¿ç”¨åœ†æ¶¦å­—ä½“ -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@500;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="520" height="520"></canvas>

        <div class="stats-bar">
            <div class="score-panel">
                <div>ğŸ¬ è±†è±† <span id="scoreDisplay">0</span></div>
                <div>â¤ï¸ ç”Ÿå‘½ <span id="livesDisplay">3</span></div>
            </div>
            <div class="button-group">
                <button class="action-btn" id="restartBtn"><span>ğŸ”„</span> é‡æ¥</button>
            </div>
        </div>

        <div class="hint-area">
            <div class="hint-item"><span class="emoji-badge">â¬†ï¸â¬‡ï¸â¬…ï¸â¡ï¸</span> ç§»åŠ¨</div>
            <div class="hint-item"><span class="emoji-badge">ğŸ‘»</span> åˆ«ç¢°å¹½çµ</div>
            <div class="hint-item"><span class="emoji-badge">ğŸ’</span> åƒå…‰é‡‘è±†</div>
        </div>
    </div>

    <script>
        (function() {
            // ---------- å°ºå¯¸è°ƒä¸º 520x520, æ ¼å­ 26x26 (20x20ç½‘æ ¼) ----------
            const CELL_SIZE = 26;
            const ROWS = 20;
            const COLS = 20;

            // åœ°å›¾å®šä¹‰ (0å¢™, 1è±†, 2ç©ºåœ°)
            const WALL = 0;
            const DOT = 1;
            const EMPTY = 2;

            // ä¸€ä¸ªæ›´æœ‰è¶£çš„è¿·å®« (å¼€é˜”+å°å¼¯é“)
            const baseMap = [
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0],
                [0,1,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0],
                [0,1,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,1,0],
                [0,1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0],
                [0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0],
                [0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0],
                [0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0],
                [0,1,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0],
                [0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0],
                [0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,1,0,1,0],
                [0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,1,0,1,0],
                [0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0],
                [0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0],
                [0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0],
                [0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0],
                [0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
            ];

            // ---------- DOM å…ƒç´  ----------
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreSpan = document.getElementById('scoreDisplay');
            const livesSpan = document.getElementById('livesDisplay');
            const restartBtn = document.getElementById('restartBtn');

            // ---------- æ¸¸æˆçŠ¶æ€å˜é‡ ----------
            let board = JSON.parse(JSON.stringify(baseMap));
            let dotsTotal = 0;
            let dotsEaten = 0;
            let score = 0;
            let lives = 3;
            let gameOver = false;
            let gameWin = false;

            // ç©å®¶ & å¹½çµ
            let pacman = { x: 1, y: 1, dir: 'RIGHT' };
            let ghosts = [
                { x: 16, y: 10, dir: 'LEFT' },
                { x: 11, y: 16, dir: 'UP' }
            ];

            // æ–¹å‘æ§åˆ¶ (ç¼“å†²åŒºæå‡æ‰‹æ„Ÿ)
            let nextDir = 'RIGHT';
            let currentDir = 'RIGHT';

            // ç§»åŠ¨é—´éš”(å¸§æ•°) â€” è°ƒå°ä¸€ç‚¹è®©ç§»åŠ¨æ›´é¡ºæ»‘ (6å¸§ â‰ˆ 60fpsä¸‹10æ¬¡/ç§’)
            const MOVE_INTERVAL = 6;
            let frameCounter = 0;

            // ç‰¹æ•ˆç›¸å…³: é—ªçƒ/åƒè±†åŠ¨ç”»
            let eatGlow = 0;          // åƒè±†æ—¶é—ªå…‰è®¡æ•°å™¨
            let ghostFright = 0;       // æœªè¢«ä½¿ç”¨, ä½†å¯ä»¥ç•™ä½œå¹½çµè¡¨æƒ… (æš‚ä¸ç”¨)

            // ---------- è¾…åŠ©å‡½æ•° ----------
            function countTotalDots() {
                let total = 0;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (baseMap[r][c] === DOT) total++;
                    }
                }
                return total;
            }
            dotsTotal = countTotalDots();

            // æ˜¯å¦å¯ä»¥èµ° (ä¸æ˜¯å¢™)
            function isWalkable(col, row) {
                return (col >= 0 && col < COLS && row >= 0 && row < ROWS && board[row][col] !== WALL);
            }

            // é‡ç½®æ¸¸æˆ
            function resetGame() {
                board = JSON.parse(JSON.stringify(baseMap));
                dotsEaten = 0;
                score = 0;
                lives = 3;
                gameOver = false;
                gameWin = false;
                pacman = { x: 1, y: 1, dir: 'RIGHT' };
                ghosts = [
                    { x: 16, y: 10, dir: 'LEFT' },
                    { x: 11, y: 16, dir: 'UP' }
                ];
                nextDir = 'RIGHT';
                currentDir = 'RIGHT';
                frameCounter = 0;
                eatGlow = 0;
                updateScoreUI();
            }

            // åƒè±†é€»è¾‘ + é—ªå…‰ç‰¹æ•ˆ
            function eatDotAtPacman() {
                const { x, y } = pacman;
                if (board[y][x] === DOT) {
                    board[y][x] = EMPTY;
                    dotsEaten++;
                    score += 10;
                    eatGlow = 8;   // é—ªå…‰8å¸§
                    if (dotsEaten >= dotsTotal) {
                        gameWin = true;
                    }
                }
            }

            // å¹½çµç§»åŠ¨ (å¢å¼ºè¶£å‘³: æœ‰æ—¶éšæœº, æœ‰æ—¶è¿½)
            function moveGhosts() {
                for (let g of ghosts) {
                    const dirs = [
                        { name: 'LEFT', dx: -1, dy: 0 },
                        { name: 'RIGHT', dx: 1, dy: 0 },
                        { name: 'UP', dx: 0, dy: -1 },
                        { name: 'DOWN', dx: 0, dy: 1 }
                    ];

                    // è®¡ç®—è·ç¦»ç©å®¶
                    let dxPlayer = pacman.x - g.x;
                    let dyPlayer = pacman.y - g.y;
                    let bestScore = -Infinity;
                    let bestDirs = [];

                    for (let d of dirs) {
                        let newX = g.x + d.dx;
                        let newY = g.y + d.dy;
                        if (!isWalkable(newX, newY)) continue;

                        // æ›¼å“ˆé¡¿è·ç¦» (è¶Šå°è¶Šå¥½)
                        let newDist = Math.abs(pacman.x - newX) + Math.abs(pacman.y - newY);
                        // åˆ†æ•° = -è·ç¦» + éšæœºå› å­(0~0.7) + æ–¹å‘æƒ¯æ€§(0.2å¦‚æœå’Œå½“å‰æ–¹å‘ä¸€è‡´)
                        let randomBoost = Math.random() * 0.7;
                        let directionBonus = (d.name === g.dir) ? 0.25 : 0.0;
                        let scoreVal = -newDist + randomBoost + directionBonus;
                        if (scoreVal > bestScore) {
                            bestScore = scoreVal;
                            bestDirs = [d.name];
                        } else if (Math.abs(scoreVal - bestScore) < 0.15) {
                            bestDirs.push(d.name);
                        }
                    }

                    if (bestDirs.length > 0) {
                        let chosen = bestDirs[Math.floor(Math.random() * bestDirs.length)];
                        let move = dirs.find(d => d.name === chosen);
                        if (move) {
                            g.x += move.dx;
                            g.y += move.dy;
                            g.dir = chosen;
                        }
                    }
                }
            }

            // ç©å®¶ç§»åŠ¨ (åŸºäºcurrentDir)
            function movePacman() {
                let dx = 0, dy = 0;
                switch (currentDir) {
                    case 'LEFT': dx = -1; break;
                    case 'RIGHT': dx = 1; break;
                    case 'UP': dy = -1; break;
                    case 'DOWN': dy = 1; break;
                }
                let newX = pacman.x + dx;
                let newY = pacman.y + dy;
                if (isWalkable(newX, newY)) {
                    pacman.x = newX;
                    pacman.y = newY;
                    pacman.dir = currentDir;   // è®°å½•é¢å‘
                    eatDotAtPacman();
                }
            }

            // å°è¯•åˆ‡æ¢æ–¹å‘ (è¾“å…¥ç¼“å†²)
            function trySwitchDirection() {
                if (!nextDir) return;
                let dx = 0, dy = 0;
                switch (nextDir) {
                    case 'LEFT': dx = -1; break;
                    case 'RIGHT': dx = 1; break;
                    case 'UP': dy = -1; break;
                    case 'DOWN': dy = 1; break;
                }
                let newX = pacman.x + dx;
                let newY = pacman.y + dy;
                if (isWalkable(newX, newY)) {
                    currentDir = nextDir;
                }
            }

            // ç¢°æ’æ£€æµ‹
            function checkGhostCollision() {
                for (let g of ghosts) {
                    if (g.x === pacman.x && g.y === pacman.y) return true;
                }
                return false;
            }

            // å¤„ç†æ­»äº¡ (å‡å‘½ã€é‡ç”Ÿ)
            function handleDeath() {
                lives--;
                if (lives <= 0) {
                    gameOver = true;
                } else {
                    // é‡ç”Ÿå›åˆ°èµ·ç‚¹, å¹½çµä½ç½®é‡ç½®, ä½†åœ°å›¾è±†å­ä¿æŒä¸å˜
                    pacman.x = 1; pacman.y = 1;
                    currentDir = 'RIGHT'; nextDir = 'RIGHT';
                    ghosts = [
                        { x: 16, y: 10, dir: 'LEFT' },
                        { x: 11, y: 16, dir: 'UP' }
                    ];
                    // å¦‚æœèµ·ç‚¹æœ‰è±†, é‡æ–°åƒä¸€ä¸‹ (ä½†è±†å­å¯èƒ½å·²ç»è¢«åƒ)
                    eatDotAtPacman();
                }
            }

            // æ›´æ–°UI
            function updateScoreUI() {
                scoreSpan.innerText = score;
                livesSpan.innerText = lives;
            }

            // ---------- æ¸¸æˆä¸»æ›´æ–°(é—´éš”ç§»åŠ¨) ----------
            function gameUpdate() {
                if (gameOver || gameWin) return;

                frameCounter++;
                if (frameCounter % MOVE_INTERVAL === 0) {
                    // è¾“å…¥ç¼“å†²åˆ‡æ¢æ–¹å‘
                    trySwitchDirection();

                    // ç©å®¶ç§»åŠ¨
                    movePacman();

                    // å¹½çµç§»åŠ¨
                    moveGhosts();

                    // ç¢°æ’æ£€æŸ¥
                    if (checkGhostCollision()) {
                        handleDeath();
                    }

                    // å‡å°‘åƒè±†é—ªå…‰
                    if (eatGlow > 0) eatGlow--;
                }
            }

            // ---------- ç”»å¾—è¶…çº§å¯çˆ± (ç”¨æˆ·ä½“éªŒ+++) ----------
            function draw() {
                ctx.clearRect(0, 0, 520, 520);

                // 1. ç»˜åˆ¶åŠé€æ˜ç½‘æ ¼ (æ›´æŸ”å’Œ)
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#3a7988';
                ctx.globalAlpha = 0.4;
                for (let i = 0; i <= COLS; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL_SIZE, 0);
                    ctx.lineTo(i * CELL_SIZE, canvas.height);
                    ctx.stroke();
                }
                for (let i = 0; i <= ROWS; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL_SIZE);
                    ctx.lineTo(canvas.width, i * CELL_SIZE);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1.0;

                // 2. ç»˜åˆ¶è±†å­ä¸å¢™å£
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const cell = board[row][col];
                        const x = col * CELL_SIZE;
                        const y = row * CELL_SIZE;

                        if (cell === WALL) {
                            // ç«‹ä½“å¢™å£ (å¸¦æ¸å˜)
                            const gradient = ctx.createLinearGradient(x, y, x+CELL_SIZE*0.8, y+CELL_SIZE*0.8);
                            gradient.addColorStop(0, '#5c8b9c');
                            gradient.addColorStop(0.7, '#2d6372');
                            ctx.fillStyle = gradient;
                            ctx.fillRect(x+2, y+2, CELL_SIZE-4, CELL_SIZE-4);
                            ctx.fillStyle = '#a3c6d1';
                            ctx.fillRect(x+4, y+4, CELL_SIZE-10, CELL_SIZE-10);
                        } else if (cell === DOT) {
                            // è±†è±†: é—ªé—ªæƒ¹äººçˆ±
                            ctx.shadowColor = '#fad275';
                            ctx.shadowBlur = 10;
                            ctx.beginPath();
                            ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, 7, 0, 2 * Math.PI);
                            ctx.fillStyle = '#fedb82';
                            ctx.fill();
                            // é«˜å…‰
                            ctx.shadowBlur = 4;
                            ctx.beginPath();
                            ctx.arc(x + CELL_SIZE/2 - 2, y + CELL_SIZE/2 - 2, 2, 0, 2*Math.PI);
                            ctx.fillStyle = '#fffde7';
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        } else {
                            // ç©ºåœ°æ¿åŠ ä¸€ç‚¹ç‚¹ç¼€å°æ˜Ÿæ˜Ÿï¼ˆéšæœºæ„Ÿï¼‰
                            if ((row+col) % 4 === 0) {
                                ctx.fillStyle = '#34707d';
                                ctx.beginPath();
                                ctx.arc(x + 13, y + 13, 2, 0, 2*Math.PI);
                                ctx.fill();
                            }
                        }
                    }
                }

                // 2.5 åƒè±†é—ªå…‰ç‰¹æ•ˆ (å…¨å±å¾®é—ª)
                if (eatGlow > 0) {
                    ctx.fillStyle = `rgba(255, 240, 170, ${eatGlow * 0.03})`;
                    ctx.fillRect(0, 0, 520, 520);
                }

                // 3. ç”»å¹½çµ (æ›´èŒ)
                for (let g of ghosts) {
                    const x = g.x * CELL_SIZE;
                    const y = g.y * CELL_SIZE;
                    // åŠé€æ˜åº•éƒ¨å½±å­
                    ctx.fillStyle = '#40252b';
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.ellipse(x+15, y+23, 10, 5, 0, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    // å¹½çµèº«ä½“
                    ctx.fillStyle = '#f75c7e';
                    ctx.shadowColor = '#b82c4a';
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc(x + 13, y + 11, 11, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.fillRect(x+4, y+12, 18, 9);
                    // çœ¼ç›
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x + 8, y + 8, 3.5, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 18, y + 8, 3.5, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.fillStyle = '#1d2731';
                    ctx.beginPath();
                    ctx.arc(x + 7, y + 7, 1.8, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + 17, y + 7, 1.8, 0, 2*Math.PI);
                    ctx.fill();

                    // å°çœ‰æ¯› (å¶å°”åå)
                    ctx.fillStyle = '#3e1d2b';
                    ctx.fillRect(x+4, y+3, 6, 2);
                    ctx.fillRect(x+14, y+3, 6, 2);
                }

                // 4. ç”»åƒè±†äºº (å¸¦åŠ¨æ€å¼ å˜´)
                const px = pacman.x * CELL_SIZE;
                const py = pacman.y * CELL_SIZE;
                let start, end;
                const mouthOffset = 0.25 * Math.PI * (0.6 + 0.4 * Math.sin(Date.now() * 0.02)); // å˜´å·´å¼€åˆåŠ¨ç”»
                switch (pacman.dir) {
                    case 'RIGHT': start = mouthOffset; end = 2*Math.PI - mouthOffset; break;
                    case 'LEFT': start = Math.PI + mouthOffset; end = Math.PI - mouthOffset; break;
                    case 'UP': start = 1.5*Math.PI + mouthOffset; end = 1.5*Math.PI - mouthOffset; break;
                    case 'DOWN': start = 0.5*Math.PI + mouthOffset; end = 0.5*Math.PI - mouthOffset; break;
                    default: start=0.2; end=1.8*Math.PI;
                }
                ctx.shadowColor = '#fabc3c';
                ctx.shadowBlur = 18;
                ctx.fillStyle = '#fce57e';
                ctx.beginPath();
                ctx.moveTo(px+13, py+13);
                ctx.arc(px+13, py+13, 12, start, end);
                ctx.closePath();
                ctx.fill();
                // çœ¼ç›
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#372e1f';
                ctx.beginPath();
                ctx.arc(px + 16, py + 8, 2.2, 0, 2*Math.PI);
                ctx.fill();

                // 5. èƒœåˆ©/ç»“æŸé®ç½© (æ›´æœ‰è®¾è®¡æ„Ÿ)
                if (gameWin) {
                    ctx.fillStyle = '#b2f0cbaa';
                    ctx.fillRect(0, 0, 520, 520);
                    ctx.font = 'bold 46px "Quicksand", cursive';
                    ctx.fillStyle = '#fee440';
                    ctx.shadowColor = '#d48b2c';
                    ctx.shadowBlur = 18;
                    ctx.fillText('âœ¨ å¤§èƒœåˆ© âœ¨', 80, 280);
                } else if (gameOver) {
                    ctx.fillStyle = '#240c1caa';
                    ctx.fillRect(0, 0, 520, 520);
                    ctx.font = 'bold 48px "Quicksand", sans-serif';
                    ctx.fillStyle = '#ffbaba';
                    ctx.shadowColor = '#ac3a3a';
                    ctx.shadowBlur = 18;
                    ctx.fillText('ğŸ˜¢ å†æ¥ä¸€å±€', 100, 290);
                }

                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
            }

            // ---------- åŠ¨ç”»å¾ªç¯ ----------
            let animFrame;
            function gameLoop() {
                gameUpdate();
                draw();
                updateScoreUI();
                animFrame = requestAnimationFrame(gameLoop);
            }

            // ---------- é”®ç›˜äº‹ä»¶ (å¹³æ»‘+é˜»æ­¢æ»šåŠ¨) ----------
            function onKeyDown(e) {
                if (e.key.startsWith('Arrow')) {
                    e.preventDefault();
                    const key = e.key;
                    if (key === 'ArrowLeft') nextDir = 'LEFT';
                    else if (key === 'ArrowRight') nextDir = 'RIGHT';
                    else if (key === 'ArrowUp') nextDir = 'UP';
                    else if (key === 'ArrowDown') nextDir = 'DOWN';
                }
            }
            window.addEventListener('keydown', onKeyDown);

            // é‡å¯
            restartBtn.addEventListener('click', () => {
                resetGame();
            });

            // å¯åŠ¨ä¸€åˆ‡
            function init() {
                resetGame();
                if (animFrame) cancelAnimationFrame(animFrame);
                animFrame = requestAnimationFrame(gameLoop);
            }
            init();

            // æ¸…ç† (éå¿…é¡»ä½†è§„èŒƒ)
            window.addEventListener('beforeunload', () => {
                if (animFrame) cancelAnimationFrame(animFrame);
                window.removeEventListener('keydown', onKeyDown);
            });
        })();
    </script>
</body>
</html>